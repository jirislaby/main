diff --git a/admin/build/build_package.sh b/admin/build/build_package.sh
index ba3dca7d..3ccc6b03 100755
--- a/admin/build/build_package.sh
+++ b/admin/build/build_package.sh
@@ -82,10 +82,13 @@ build_package_psi() {
         cp $mqtdir/bin/QtNetwork4.dll $arch_prefix
         cp $mqtdir/bin/QtXml4.dll $arch_prefix
         cp $mqtdir/bin/QtGui4.dll $arch_prefix
+        cp $mqtdir/bin/QtSql4.dll $arch_prefix
         mkdir -p $arch_prefix/imageformats
         cp $mqtdir/plugins/imageformats/qgif4.dll $arch_prefix/imageformats
         cp $mqtdir/plugins/imageformats/qjpeg4.dll $arch_prefix/imageformats
         cp $mqtdir/plugins/imageformats/qmng4.dll $arch_prefix/imageformats
+        mkdir -p $arch_prefix/sqldrivers
+        cp $mqtdir/plugins/sqldrivers/qsqlite4.dll
         cp $deps_base/$qca_win_dir/$target_arch/bin/qca2.dll $arch_prefix
         mkdir -p $arch_prefix/crypto
         cp $deps_base/$qca_win_dir/$target_arch/plugins/crypto/qca-gnupg2.dll $arch_prefix/crypto
@@ -126,8 +129,8 @@ build_package_psi() {
             QT_LIB_PATH=$QTDIR/lib
         fi
         cd $psi_base
-        export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework
-        ./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal
+        export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:$deps_base/$qjson_mac_dir/lib
+        ./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal --with-qjson-lib=$deps_base/$qjson_mac_dir/lib
         make
     fi
 }
diff --git a/admin/build/devconfig.sh b/admin/build/devconfig.sh
index 3adefef3..00e8a62d 100755
--- a/admin/build/devconfig.sh
+++ b/admin/build/devconfig.sh
@@ -60,7 +60,7 @@ if [ "$platform" == "win" ]; then
     fi
     mqtdir=`get_msys_path $qtdir`
 
-    PATH=$mqtdir/bin:$PATH ./configure.exe --qtdir=$qtdir --release --with-qca-inc=$deps_base/$qca_win_dir/$target_arch/include --with-qca-lib=$deps_base/$qca_win_dir/$target_arch/lib --with-zlib-inc=$deps_base/$zlib_win_dir/$target_arch/include --with-zlib-lib=$deps_base/$zlib_win_dir/$target_arch/lib --with-aspell-inc=$deps_base/$aspell_win_dir/$target_arch/include --with-aspell-lib=$deps_base/$aspell_win_dir/$target_arch/lib
+    PATH=$mqtdir/bin:$PATH ./configure.exe --qtdir=$qtdir --release --with-qca-inc=$deps_base/$qca_win_dir/$target_arch/include --with-qca-lib=$deps_base/$qca_win_dir/$target_arch/lib --with-zlib-inc=$deps_base/$zlib_win_dir/$target_arch/include --with-zlib-lib=$deps_base/$zlib_win_dir/$target_arch/lib --with-aspell-inc=$deps_base/$aspell_win_dir/$target_arch/include --with-aspell-lib=$deps_base/$aspell_win_dir/$target_arch/lib --with-qjson-inc=$deps_base/$qjson_win_dir/$target_arch/include --with-qjson-lib=$deps_base/$qjson_win_dir/$target_arch/lib
 
     rm -f $build_base/devenv
     touch $build_base/devenv
@@ -79,8 +79,8 @@ else
     if [ "$QT_PLUGIN_PATH" == "" ]; then
         QT_PLUGIN_PATH=$QTDIR/plugins
     fi
-    export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework
-    ./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal
+    export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:$deps_base/$qjson_mac_dir/lib
+    ./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal --with-qjson-lib=$deps_base/$qjson_mac_dir/lib
 
     # remove some gstbundle problem files
     rm -f $deps_base/$gstbundle_mac_dir/uni/lib/gstreamer-0.10/libgstximagesink.so
@@ -91,7 +91,7 @@ else
     rm -f $build_base/devenv
     touch $build_base/devenv
     echo "export DYLD_LIBRARY_PATH=$deps_base/$gstbundle_mac_dir/uni/lib:\$DYLD_LIBRARY_PATH" >> $build_base/devenv
-    echo "export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:\$DYLD_FRAMEWORK_PATH" >> $build_base/devenv
+    echo "export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:$deps_base/$qjson_mac_dir/lib:\$DYLD_FRAMEWORK_PATH" >> $build_base/devenv
     echo "export GST_PLUGIN_PATH=$deps_base/$gstbundle_mac_dir/uni/lib/gstreamer-0.10" >> $build_base/devenv
     echo "export GST_REGISTRY_FORK=no" >> $build_base/devenv
     echo "export QT_PLUGIN_PATH=$QT_PLUGIN_PATH:$deps_base/$qca_mac_dir/plugins" >> $build_base/devenv
diff --git a/admin/build/package_info b/admin/build/package_info
index fdea71bf..7310eb62 100644
--- a/admin/build/package_info
+++ b/admin/build/package_info
@@ -39,3 +39,11 @@ psimedia_win_dir=psimedia-20120725-win
 psimedia_mac_file=psimedia-20120725-mac.tar.bz2
 psimedia_mac_url=http://psi-im.org/files/deps/psimedia-20120725-mac.tar.bz2
 psimedia_mac_dir=psimedia-20120725-mac
+
+qjson_win_file=qjson-0.8.1-win.zip
+qjson_win_url=http://psi-im.org/files/deps/qjson-0.8.1-win.zip
+qjson_win_dir=qjson-0.8.1-win
+
+qjson_mac_file=qjson-0.8.1-mac.tar.bz2
+qjson_mac_url=http://psi-im.org/files/deps/qjson-0.8.1-mac.tar.bz2
+qjson_mac_dir=qjson-0.8.1-mac
diff --git a/admin/build/prep_dist.sh b/admin/build/prep_dist.sh
index 341477fa..43f25ee0 100755
--- a/admin/build/prep_dist.sh
+++ b/admin/build/prep_dist.sh
@@ -45,8 +45,8 @@ if [ "$platform" == "mac" ]; then
 
     mkdir -p $target_dist_base
 
-    QT_FRAMEWORKS="QtCore QtNetwork QtXml QtGui"
-    QT_PLUGINS="imageformats/libqjpeg.dylib imageformats/libqgif.dylib imageformats/libqmng.dylib"
+    QT_FRAMEWORKS="QtCore QtNetwork QtXml QtGui QtSql"
+    QT_PLUGINS="imageformats/libqjpeg.dylib imageformats/libqgif.dylib imageformats/libqmng.dylib sqldrivers/libqsqlite.dylib"
     QCA_PLUGINS="crypto/libqca-ossl.dylib crypto/libqca-gnupg.dylib"
 
     cp -a $psi_base/psi.app $target_dist_base/Psi.app
@@ -57,6 +57,7 @@ if [ "$platform" == "mac" ]; then
     done
 
     install_name_tool -change qca.framework/Versions/2/qca @executable_path/../Frameworks/qca.framework/Versions/2/qca $contentsdir/MacOS/psi
+    install_name_tool -change qjson.framework/Versions/0.8.1/qjson @executable_path/../Frameworks/qjson.framework/Versions/0.8.1/qjson $contentsdir/MacOS/psi
 
     mkdir -p $contentsdir/Frameworks
     for f in $QT_FRAMEWORKS; do
@@ -80,8 +81,14 @@ if [ "$platform" == "mac" ]; then
     cp -a $deps_base/$qca_mac_dir/lib/qca.framework $contentsdir/Frameworks
     cleanup_framework $contentsdir/Frameworks/qca.framework qca 2
     install_name_tool -id @executable_path/../Frameworks/qca.framework/Versions/2/qca $contentsdir/Frameworks/qca.framework/qca
+
+    cp -a $deps_base/$qjson_mac_dir/lib/qjson.framework $contentsdir/Frameworks
+    cleanup_framework $contentsdir/Frameworks/qjson.framework qjson 0.8.1
+    install_name_tool -id @executable_path/../Frameworks/qjson.framework/Versions/0.8.1/qjson $contentsdir/Frameworks/qjson.framework/qjson
+
     for g in $QT_FRAMEWORKS; do
         install_name_tool -change $g.framework/Versions/4/$g @executable_path/../Frameworks/$g.framework/Versions/4/$g $contentsdir/Frameworks/qca.framework/qca
+        install_name_tool -change $g.framework/Versions/4/$g @executable_path/../Frameworks/$g.framework/Versions/4/$g $contentsdir/Frameworks/qjson.framework/qjson
     done
 
     mkdir -p $contentsdir/Plugins/crypto
diff --git a/psi.qc b/psi.qc
index 12be7a27..7d8b565a 100644
--- a/psi.qc
+++ b/psi.qc
@@ -17,6 +17,9 @@
   <dep type='qca'>
     <required/>
   </dep>
+  <dep type='qjson'>
+    <required/>
+  </dep>
   <dep type='zlib'>
     <required/>
   </dep>
diff --git a/qcm/qjson.qcm b/qcm/qjson.qcm
new file mode 100644
index 00000000..d0c38438
--- /dev/null
+++ b/qcm/qjson.qcm
@@ -0,0 +1,166 @@
+/*
+-----BEGIN QCMOD-----
+name: QJson
+arg: with-qjson-inc=[path],Path to QJson include files
+arg: with-qjson-lib=[path],Path to QJson library or framework files
+-----END QCMOD-----
+*/
+
+// adapted from json.prf
+static QString internal_json_prf(const QString &incdir, const QString &libdir, const QString &frameworkdir)
+{
+    QString out = QString(
+"QJSON_INCDIR = %1\n"
+"QJSON_LIBDIR = %2\n"
+"QJSON_FRAMEWORKDIR = %3\n"
+"\n"
+"CONFIG *= qt\n"
+"\n"
+"LINKAGE =\n"
+"\n"
+"!isEmpty(QJSON_FRAMEWORKDIR): {\n"
+"    framework_dir = $$QJSON_FRAMEWORKDIR\n"
+"    exists($$framework_dir/qjson.framework) {\n"
+"        QMAKE_FRAMEWORKPATH *= $$framework_dir\n"
+"        LIBS *= -F$$framework_dir\n"
+"        INCLUDEPATH += $$framework_dir/qjson.framework\n"
+"        LINKAGE = -framework qjson\n"
+"    }\n"
+"}\n"
+"\n"
+"# else, link normally\n"
+"isEmpty(LINKAGE) {\n"
+"    !isEmpty(QJSON_INCDIR):INCLUDEPATH += $$QJSON_INCDIR\n"
+"    !isEmpty(QJSON_LIBDIR):LIBS += -L$$QJSON_LIBDIR\n"
+"    LINKAGE = -lqjson\n"
+"    CONFIG(debug, debug|release) {\n"
+"        windows:LINKAGE = -lqjsond\n"
+"        mac:LINKAGE = -lqjson_debug\n"
+"    }\n"
+"}\n"
+"\n"
+"LIBS += $$LINKAGE\n"
+    ).arg(incdir, libdir, frameworkdir);
+    return out;
+}
+
+// set either libdir or frameworkdir, but not both
+static bool qjson_try(Conf *conf, const QString &incdir, const QString &libdir, const QString &frameworkdir, bool release, bool debug, QString *_prf)
+{
+    QString proextra;
+    QString prf = internal_json_prf(incdir, libdir, frameworkdir);
+    proextra =
+    "CONFIG += qt\n"
+    "CONFIG -= debug_and_release debug release\n"
+    "QT -= gui\n";
+    proextra += prf;
+
+    QString str =
+    "#include <qjson/parser.h>\n"
+    "\n"
+    "int main()\n"
+    "{\n"
+    "    return 0;\n"
+    "}\n";
+
+    // test desired versions, potentially both release and debug
+
+    if(release)
+    {
+        int ret;
+        if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra + "CONFIG += release\n", &ret) || ret != 0)
+            return false;
+    }
+
+    if(debug)
+    {
+        int ret;
+        if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra + "CONFIG += debug\n", &ret) || ret != 0)
+            return false;
+    }
+
+    *_prf = prf;
+    return true;
+}
+
+static bool qjson_try_lib(Conf *conf, const QString &incdir, const QString &libdir, bool release, bool debug, QString *prf)
+{
+    return qjson_try(conf, incdir, libdir, QString(), release, debug, prf);
+}
+
+static bool qjson_try_framework(Conf *conf, const QString &frameworkdir, bool release, bool debug, QString *prf)
+{
+    return qjson_try(conf, QString(), QString(), frameworkdir, release, debug, prf);
+}
+
+//----------------------------------------------------------------------------
+// qc_qjson
+//----------------------------------------------------------------------------
+class qc_qjson : public ConfObj
+{
+public:
+    qc_qjson(Conf *c) : ConfObj(c) {}
+    QString name() const { return "QJson"; }
+    QString shortname() const { return "qjson"; }
+    bool exec()
+    {
+#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
+        // get the build mode
+#ifdef QC_BUILDMODE
+        bool release = qc_buildmode_release;
+        bool debug = qc_buildmode_debug;
+#else
+        // else, default to just release mode
+        bool release = true;
+        bool debug = false;
+#endif
+
+        QString qjson_incdir, qjson_libdir, qjson_json_prf;
+        qjson_incdir = conf->getenv("QC_WITH_QJSON_INC");
+        qjson_libdir = conf->getenv("QC_WITH_QJSON_LIB");
+
+#if defined(Q_OS_MAC)
+        if(!qjson_libdir.isEmpty() && qjson_try_framework(conf, qjson_libdir, release, debug, &qjson_json_prf))
+        {
+            conf->addExtra(qjson_json_prf);
+            return true;
+        }
+#endif
+
+        if(!qjson_incdir.isEmpty() && !qjson_libdir.isEmpty() && qjson_try_lib(conf, qjson_incdir, qjson_libdir, release, debug, &qjson_json_prf))
+        {
+            conf->addExtra(qjson_json_prf);
+            return true;
+        }
+
+        QStringList incs;
+        QString version, libs, other;
+        if(conf->findPkgConfig("QJson", VersionAny, QString(), &version, &incs, &libs, &other))
+        {
+            for(int n = 0; n < incs.count(); ++n)
+                conf->addIncludePath(incs[n]);
+            if(!libs.isEmpty())
+                conf->addLib(libs);
+            return true;
+        }
+
+        QStringList prefixes;
+        prefixes += "/usr";
+        prefixes += "/usr/local";
+
+        for(int n = 0; n < prefixes.count(); ++n)
+        {
+            const QString &prefix = prefixes[n];
+            if(qjson_try_lib(conf, prefix + "/include", prefix + "/lib", release, debug, &qjson_json_prf))
+            {
+                conf->addExtra(qjson_json_prf);
+                return true;
+            }
+        }
+
+        return false;
+#else
+        return true;
+#endif
+    }
+};
diff --git a/src/edbsqlite.cpp b/src/edbsqlite.cpp
new file mode 100644
index 00000000..972d9668
--- /dev/null
+++ b/src/edbsqlite.cpp
@@ -0,0 +1,874 @@
+/*
+ * edbsqlite.cpp
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QSqlError>
+#include <QSqlDriver>
+#ifndef HAVE_QT5
+#include <qjson/parser.h>
+#include "qjson/serializer.h"
+#else
+#include <QJsonArray>
+#include <QJsonDocument>
+#include <QJsonObject>
+#endif
+
+#include "edbsqlite.h"
+//#include "common.h"
+#include "applicationinfo.h"
+#include "psicontactlist.h"
+#include "jidutil.h"
+#include "historyimp.h"
+
+#define FAKEDELAY 0
+
+using namespace XMPP;
+
+//----------------------------------------------------------------------------
+// EDBSqLite
+//----------------------------------------------------------------------------
+
+EDBSqLite::EDBSqLite(PsiCon *psi) : EDB(psi),
+    transactionsCounter(0),
+    lastCommitTime(QDateTime::currentDateTime()),
+    commitTimer(NULL),
+    mirror_(NULL)
+{
+    status = NotActive;
+    QString path = ApplicationInfo::historyDir() + "/history.db";
+    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "history");
+    db.setDatabaseName(path);
+    if (!db.open()) {
+        qWarning("%s\n%s", "EDBSqLite::EDBSqLite(): Can't open base.", qUtf8Printable(db.lastError().text()));
+        return;
+    }
+    QSqlQuery query(db);
+    query.exec("PRAGMA foreign_keys = ON;");
+    setInsertingMode(Normal);
+    if (db.tables(QSql::Tables).size() == 0) {
+        // no tables found.
+        if (db.transaction()) {
+            query.exec("CREATE TABLE `system` ("
+                "`key` TEXT, "
+                "`value` TEXT"
+                ");");
+            query.exec("CREATE TABLE `accounts` ("
+                "`id` TEXT, "
+                "`lifetime` INTEGER"
+                ");");
+            query.exec("CREATE TABLE `contacts` ("
+                "`id` INTEGER NOT NULL PRIMARY KEY ASC, "
+                "`acc_id` TEXT, "
+                "`type` INTEGER, "
+                "`jid` TEXT, "
+                "`lifetime` INTEGER"
+                ");");
+            query.exec("CREATE TABLE `events` ("
+                "`id` INTEGER NOT NULL PRIMARY KEY ASC, "
+                "`contact_id` INTEGER NOT NULL REFERENCES `contacts`(`id`) ON DELETE CASCADE, "
+                "`resource` TEXT, "
+                "`date` TEXT, "
+                "`type` INTEGER, "
+                "`direction` INTEGER, "
+                "`subject` TEXT, "
+                "`m_text` TEXT, "
+                "`lang` TEXT, "
+                "`extra_data` TEXT"
+                ");");
+            query.exec("CREATE INDEX `key` ON `system` (`key`);");
+            query.exec("CREATE INDEX `jid` ON `contacts` (`jid`);");
+            query.exec("CREATE INDEX `contact_id` ON `events` (`contact_id`);");
+            query.exec("CREATE INDEX `date` ON `events` (`date`);");
+            if (db.commit()) {
+                status = Commited;
+                setStorageParam("version", "0.1");
+                setStorageParam("import_start", "yes");
+            }
+        }
+    }
+    else
+        status = Commited;
+}
+
+EDBSqLite::~EDBSqLite()
+{
+    commit();
+    {
+        QSqlDatabase db = QSqlDatabase::database("history", false);
+        if (db.isOpen())
+            db.close();
+    }
+    QSqlDatabase::removeDatabase("history");
+}
+
+bool EDBSqLite::init()
+{
+    if (status == NotActive)
+        return false;
+
+    if (!getStorageParam("import_start").isEmpty()) {
+        if (!importExecute()) {
+            status = NotActive;
+            return false;
+        }
+    }
+
+    setMirror(new EDBFlatFile(psi()));
+    return true;
+}
+
+int EDBSqLite::features() const
+{
+    return SeparateAccounts | PrivateContacts | AllContacts | AllAccounts;
+}
+
+int EDBSqLite::get(const QString &accId, const XMPP::Jid &jid, QDateTime date, int direction, int start, int len)
+{
+    item_query_req *r = new item_query_req;
+    r->accId = accId;
+    r->j     = jid;
+    r->type  = item_query_req::Type_get;
+    r->start = start;
+    r->len   = len < 1 ? 1 : len;
+    r->dir   = direction;
+    r->date  = date;
+    r->id    = genUniqueId();
+    rlist.append(r);
+
+    QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+    return r->id;
+}
+
+int EDBSqLite::find(const QString &accId, const QString &str, const XMPP::Jid &jid, const QDateTime date, int direction)
+{
+    item_query_req *r = new item_query_req;
+    r->accId   = accId;
+    r->j       = jid;
+    r->type    = item_query_req::Type_find;
+    r->len     = 1;
+    r->dir     = direction;
+    r->findStr = str;
+    r->date    = date;
+    r->id      = genUniqueId();
+    rlist.append(r);
+
+    QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+    return r->id;
+}
+
+int EDBSqLite::append(const QString &accId, const XMPP::Jid &jid, const PsiEvent::Ptr &e, int type)
+{
+    item_query_req *r = new item_query_req;
+    r->accId   = accId;
+    r->j       = jid;
+    r->jidType = type;
+    r->type    = item_query_req::Type_append;
+    r->event   = e;
+    if ( !r->event ) {
+        qWarning("EDBSqLite::append(): Attempted to append incompatible type.");
+        delete r;
+        return 0;
+    }
+    r->id      = genUniqueId();
+    rlist.append(r);
+
+    QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+
+    if (mirror_)
+        mirror_->append(accId, jid, e, type);
+
+    return r->id;
+}
+
+int EDBSqLite::erase(const QString &accId, const XMPP::Jid &jid)
+{
+    item_query_req *r = new item_query_req;
+    r->accId = accId;
+    r->j     = jid;
+    r->type  = item_query_req::Type_erase;
+    r->id    = genUniqueId();
+    rlist.append(r);
+
+    QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+
+    if (mirror_)
+        mirror_->erase(accId, jid);
+
+    return r->id;
+}
+
+QList<EDB::ContactItem> EDBSqLite::contacts(const QString &accId, int type)
+{
+    QList<ContactItem> res;
+    EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryContactsList, accId.isEmpty(), true);
+    query->bindValue(":type", type);
+    if (!accId.isEmpty())
+        query->bindValue(":acc_id", accId);
+    if (query->exec()) {
+        while (query->next()) {
+            const QSqlRecord &rec = query->record();
+            res.append(ContactItem(rec.value("acc_id").toString(), XMPP::Jid(rec.value("jid").toString())));
+        }
+        query->freeResult();
+    }
+    return res;
+}
+
+quint64 EDBSqLite::eventsCount(const QString &accId, const XMPP::Jid &jid)
+{
+    quint64 res = 0;
+    bool fAccAll  = accId.isEmpty();
+    bool fContAll = jid.isEmpty();
+    EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryRowCount, fAccAll, fContAll);
+    if (!fAccAll)
+        query->bindValue(":acc_id", accId);
+    if (!fContAll)
+        query->bindValue(":jid", jid.full());
+    if (query->exec()) {
+        if (query->next())
+            res = query->record().value("count").toULongLong();
+        query->freeResult();
+    }
+    return res;
+}
+
+QString EDBSqLite::getStorageParam(const QString &key)
+{
+    QSqlQuery query(QSqlDatabase::database("history"));
+    query.prepare("SELECT `value` FROM `system` WHERE `key` = :key;");
+    query.bindValue(":key", key);
+    if (query.exec() && query.next())
+        return query.record().value("value").toString();
+    return QString();
+}
+
+void EDBSqLite::setStorageParam(const QString &key, const QString &val)
+{
+    transaction(true);
+    QSqlQuery query(QSqlDatabase::database("history"));
+    if (val.isEmpty()) {
+        query.prepare("DELETE FROM `system` WHERE `key` = :key;");
+        query.bindValue(":key", key);
+        query.exec();
+    }
+    else {
+        query.prepare("SELECT COUNT(*) AS `count` FROM `system` WHERE `key` = :key;");
+        query.bindValue(":key", key);
+        if (query.exec() && query.next() && query.record().value("count").toULongLong() != 0) {
+            query.prepare("UPDATE `system` SET `value` = :val WHERE `key` = :key;");
+            query.bindValue(":key", key);
+            query.bindValue(":val", val);
+            query.exec();
+        }
+        else {
+            query.prepare("INSERT INTO `system` (`key`, `value`) VALUES (:key, :val);");
+            query.bindValue(":key", key);
+            query.bindValue(":val", val);
+            query.exec();
+        }
+    }
+    commit();
+}
+
+void EDBSqLite::setInsertingMode(InsertMode mode)
+{
+    // in the case of a flow of new records
+    if (mode == Import) {
+        // Commit after 10000 inserts and every 5 seconds
+        maxUncommitedRecs = 10000;
+        maxUncommitedSecs = 5;
+    } else {
+        // Commit after 3 inserts and every 1 second
+        maxUncommitedRecs = 3;
+        maxUncommitedSecs = 1;
+    }
+    // Commit if there were no new additions for 1 second
+    commitByTimeoutSecs = 1;
+    //--
+    commit();
+}
+
+void EDBSqLite::setMirror(EDBFlatFile *mirr)
+{
+    if (mirr != mirror_) {
+        if (mirror_)
+            delete mirror_;
+        mirror_ = mirr;
+    }
+}
+
+EDBFlatFile *EDBSqLite::mirror() const
+{
+    return mirror_;
+}
+
+void EDBSqLite::performRequests()
+{
+    if (rlist.isEmpty())
+        return;
+
+    item_query_req *r = rlist.takeFirst();
+    const int type = r->type;
+
+    if (type == item_query_req::Type_append) {
+        bool b = appendEvent(r->accId, r->j, r->event, r->jidType);
+        writeFinished(r->id, b);
+    }
+
+    else if (type == item_query_req::Type_get) {
+        commit();
+        bool fContAll = r->j.isEmpty();
+        bool fAccAll  = r->accId.isEmpty();
+        QueryType queryType;
+        if (r->date.isNull()) {
+            if (r->dir == Forward)
+                queryType = QueryOldest;
+            else
+                queryType = QueryLatest;
+        } else {
+            if (r->dir == Backward)
+                queryType = QueryDateBackward;
+            else
+                queryType = QueryDateForward;
+        }
+        EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(queryType, fAccAll, fContAll);
+        if (!fContAll)
+            query->bindValue(":jid", r->j.full());
+        if (!fAccAll)
+            query->bindValue(":acc_id", r->accId);
+        if (!r->date.isNull())
+            query->bindValue(":date", r->date);
+        query->bindValue(":start", r->start);
+        query->bindValue(":cnt", r->len);
+        EDBResult result;
+        if (query->exec()) {
+            while (query->next()) {
+                PsiEvent::Ptr e(getEvent(query->record()));
+                if (e) {
+                    QString id = query->record().value("id").toString();
+                    result.append(EDBItemPtr(new EDBItem(e, id)));
+                }
+            }
+            query->freeResult();
+        }
+        int beginRow;
+        if (r->dir == Forward && r->date.isNull()) {
+            beginRow = r->start;
+        } else {
+            int cnt = rowCount(r->accId, r->j, r->date);
+            if (r->dir == Backward) {
+                beginRow = cnt - r->len + 1;
+                if (beginRow < 0)
+                    beginRow = 0;
+            } else {
+                beginRow = cnt + 1;
+            }
+        }
+        resultReady(r->id, result, beginRow);
+
+    } else if(type == item_query_req::Type_find) {
+        commit();
+        bool fContAll = r->j.isEmpty();
+        bool fAccAll  = r->accId.isEmpty();
+        EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryFindText, fAccAll, fContAll);
+        if (!fContAll)
+            query->bindValue(":jid", r->j.full());
+        if (!fAccAll)
+            query->bindValue(":acc_id", r->accId);
+        EDBResult result;
+        if (query->exec()) {
+            QString str = r->findStr.toLower();
+            while (query->next()) {
+                const QSqlRecord rec = query->record();
+                if (!rec.value("m_text").toString().toLower().contains(str, Qt::CaseSensitive))
+                    continue;
+                PsiEvent::Ptr e(getEvent(rec));
+                if (e) {
+                    QString id = rec.value("id").toString();
+                    EDBItemPtr eip = EDBItemPtr(new EDBItem(e, id));
+                    result.append(eip);
+                }
+            }
+            query->freeResult();
+        }
+        resultReady(r->id, result, 0);
+
+    } else if(type == item_query_req::Type_erase) {
+        writeFinished(r->id, eraseHistory(r->accId, r->j));
+    }
+
+    delete r;
+}
+
+bool EDBSqLite::appendEvent(const QString &accId, const XMPP::Jid &jid, const PsiEvent::Ptr &e, int jidType)
+{
+    QSqlDatabase db = QSqlDatabase::database("history");
+    const qint64 contactId = ensureJidRowId(accId, jid, jidType);
+    if (contactId == 0)
+        return false;
+
+    QDateTime dTime;
+    int nType = 0;
+
+    if (e->type() == PsiEvent::Message) {
+        MessageEvent::Ptr me = e.staticCast<MessageEvent>();
+        const Message &m = me->message();
+        dTime = m.timeStamp();
+        if (m.type() == "chat")
+            nType = 1;
+        else if(m.type() == "error")
+            nType = 4;
+        else if(m.type() == "headline")
+            nType = 5;
+
+    } else if (e->type() == PsiEvent::Auth) {
+        AuthEvent::Ptr ae = e.staticCast<AuthEvent>();
+        dTime = ae->timeStamp();
+        QString subType = ae->authType();
+        if(subType == "subscribe")
+            nType = 3;
+        else if(subType == "subscribed")
+            nType = 6;
+        else if(subType == "unsubscribe")
+            nType = 7;
+        else if(subType == "unsubscribed")
+            nType = 8;
+    } else
+        return false;
+
+    int nDirection = e->originLocal() ? 1 : 2;
+    if (!transaction(false))
+        return false;
+
+    PreparedQuery *query = queryes.getPreparedQuery(QueryInsertEvent, false, false);
+    query->bindValue(":contact_id", contactId);
+    query->bindValue(":resource", (jidType != GroupChatContact) ? jid.resource() : "");
+    query->bindValue(":date", dTime);
+    query->bindValue(":type", nType);
+    query->bindValue(":direction", nDirection);
+    if (nType == 0 || nType == 1 || nType == 4 || nType == 5) {
+        MessageEvent::Ptr me = e.staticCast<MessageEvent>();
+        const Message &m = me->message();
+        QString lang = m.lang();
+        query->bindValue(":subject", m.subject(lang));
+        query->bindValue(":m_text", m.body(lang));
+        query->bindValue(":lang", lang);
+        QString extraData;
+        const UrlList &urls = m.urlList();
+        if (!urls.isEmpty()) {
+            QVariantMap xepList;
+            QVariantList urlList;
+            foreach (const Url &url, urls)
+                if (!url.url().isEmpty()) {
+                    QVariantList urlItem;
+                    urlItem.append(QVariant(url.url()));
+                    if (!url.desc().isEmpty())
+                        urlItem.append(QVariant(url.desc()));
+                    urlList.append(QVariant(urlItem));
+                }
+            xepList["jabber:x:oob"] = QVariant(urlList);
+#ifndef HAVE_QT5
+            QJson::Serializer serializer;
+            extraData = QString::fromUtf8(serializer.serialize(xepList));
+#else
+            QJsonDocument doc(QJsonObject::fromVariantMap(xepList));
+            extraData = QString::fromUtf8(doc.toBinaryData());
+#endif
+        }
+        query->bindValue(":extra_data", extraData);
+    }
+    else {
+        query->bindValue(":subject", QVariant(QVariant::String));
+        query->bindValue(":m_text", QVariant(QVariant::String));
+        query->bindValue(":lang", QVariant(QVariant::String));
+        query->bindValue(":extra_data", QVariant(QVariant::String));
+    }
+    bool res = query->exec();
+    return res;
+}
+
+PsiEvent::Ptr EDBSqLite::getEvent(const QSqlRecord &record)
+{
+    PsiAccount *pa = psi()->contactList()->getAccount(record.value("acc_id").toString());
+
+    int type = record.value("type").toInt();
+
+    if(type == 0 || type == 1 || type == 4 || type == 5) {
+        Message m;
+        m.setTimeStamp(record.value("date").toDateTime());
+        if(type == 1)
+            m.setType("chat");
+        else if(type == 4)
+            m.setType("error");
+        else if(type == 5)
+            m.setType("headline");
+        else
+            m.setType("");
+        m.setFrom(Jid(record.value("jid").toString()));
+        QVariant text = record.value("m_text");
+        if (!text.isNull()) {
+            m.setBody(text.toString());
+            m.setLang(record.value("lang").toString());
+            m.setSubject(record.value("subject").toString());
+        }
+        m.setSpooled(true);
+        QString extraStr = record.value("extra_data").toString();
+        if (!extraStr.isEmpty()) {
+#ifndef HAVE_QT5
+            QJson::Parser parser;
+#endif
+            bool fOk;
+#ifndef HAVE_QT5
+            QVariantMap extraData = parser.parse(extraStr.toUtf8(), &fOk).toMap();
+#else
+            QJsonDocument doc = QJsonDocument::fromJson(extraStr.toUtf8());
+            fOk = !doc.isNull();
+            QVariantMap extraData = doc.object().toVariantMap();
+#endif
+            if (fOk) {
+                foreach (const QVariant &urlItem, extraData["jabber:x:oob"].toList()) {
+                    QVariantList itemList = urlItem.toList();
+                    if (!itemList.isEmpty()) {
+                        QString url = itemList.at(0).toString();
+                        QString desc;
+                        if (itemList.size() > 1)
+                            desc = itemList.at(1).toString();
+                        m.urlAdd(Url(url, desc));
+                    }
+                }
+            }
+        }
+        MessageEvent::Ptr me(new MessageEvent(m, pa));
+        me->setOriginLocal((record.value("direction").toInt() == 1));
+        return me.staticCast<PsiEvent>();
+    }
+
+    if(type == 2 || type == 3 || type == 6 || type == 7 || type == 8) {
+        QString subType = "subscribe";
+        // if(type == 2) { // Not used (stupid "system message" from Psi <= 0.8.6)
+        if(type == 3)
+            subType = "subscribe";
+        else if(type == 6)
+            subType = "subscribed";
+        else if(type == 7)
+            subType = "unsubscribe";
+        else if(type == 8)
+            subType = "unsubscribed";
+
+        AuthEvent::Ptr ae(new AuthEvent(Jid(record.value("jid").toString()), subType, pa));
+        ae->setTimeStamp(record.value("date").toDateTime());
+        return ae.staticCast<PsiEvent>();
+    }
+    return PsiEvent::Ptr();
+}
+
+qint64 EDBSqLite::ensureJidRowId(const QString &accId, const XMPP::Jid &jid, int type)
+{
+    if (jid.isEmpty())
+        return 0;
+    QString sJid = (type == GroupChatContact) ? jid.full() : jid.bare();
+    QString sKey = accId + "|" + sJid;
+    qint64 id = jidsCache.value(sKey, 0);
+    if (id != 0)
+        return id;
+
+    EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryJidRowId, false, false);
+    query->bindValue(":jid", sJid);
+    query->bindValue(":acc_id", accId);
+    if (query->exec()) {
+        if (query->first()) {
+            id = query->record().value("id").toLongLong();
+        } else {
+            //
+            QSqlQuery queryIns(QSqlDatabase::database("history"));
+            queryIns.prepare("INSERT INTO `contacts` (`acc_id`, `type`, `jid`, `lifetime`)"
+                " VALUES (:acc_id, :type, :jid, -1);");
+            queryIns.bindValue(":acc_id", accId);
+            queryIns.bindValue(":type", type);
+            queryIns.bindValue(":jid", sJid);
+            if (queryIns.exec()) {
+                id  = queryIns.lastInsertId().toLongLong();
+            }
+        }
+        query->freeResult();
+        if (id != 0)
+            jidsCache[sKey] = id;
+    }
+    return id;
+}
+
+int EDBSqLite::rowCount(const QString &accId, const XMPP::Jid &jid, QDateTime before)
+{
+    bool fAccAll  = accId.isEmpty();
+    bool fContAll = jid.isEmpty();
+    QueryType type;
+    if (before.isNull())
+        type = QueryRowCount;
+    else
+        type = QueryRowCountBefore;
+    PreparedQuery *query = queryes.getPreparedQuery(type, fAccAll, fContAll);
+    if (!fContAll)
+        query->bindValue(":jid", jid.full());
+    if (!fAccAll)
+        query->bindValue(":acc_id", accId);
+    if (!before.isNull())
+        query->bindValue(":date", before);
+    int res = 0;
+    if (query->exec()) {
+        if (query->next()) {
+            res = query->record().value("count").toInt();
+        }
+        query->freeResult();
+    }
+    return res;
+}
+
+bool EDBSqLite::eraseHistory(const QString &accId, const XMPP::Jid &jid)
+{
+    bool res = false;
+    if (!transaction(true))
+        return false;
+
+    if (accId.isEmpty() && jid.isEmpty()) {
+        QSqlQuery query(QSqlDatabase::database("history"));
+        //if (query.exec("DELETE FROM `events`;"))
+            if (query.exec("DELETE FROM `contacts`;")) {
+                jidsCache.clear();
+                res = true;
+            }
+    }
+    else {
+        PreparedQuery *query = queryes.getPreparedQuery(QueryJidRowId, false, false);
+        query->bindValue(":jid", jid.full());
+        query->bindValue(":acc_id", accId);
+        if (query->exec()) {
+            if (query->next()) {
+                const qint64 id = query->record().value("id").toLongLong();
+                QSqlQuery query2(QSqlDatabase::database("history"));
+                query2.prepare("DELETE FROM `events` WHERE `contact_id` = :id;");
+                query2.bindValue(":id", id);
+                if (query2.exec()) {
+                    res = true;
+                    query2.prepare("DELETE FROM `contacts` WHERE `id` = :id AND `lifetime` = -1;");
+                    query2.bindValue(":id", id);
+                    if (query2.exec()) {
+                        if (query2.numRowsAffected() > 0)
+                            jidsCache.clear();
+                    } else
+                        res = false;
+                }
+            }
+            query->freeResult();
+        }
+    }
+    if (res)
+        res = commit();
+    else
+        rollback();
+    return res;
+}
+
+bool EDBSqLite::transaction(bool now)
+{
+    if (status == NotActive)
+        return false;
+    if (now || transactionsCounter >= maxUncommitedRecs
+            || lastCommitTime.secsTo(QDateTime::currentDateTime()) >= maxUncommitedSecs)
+        if (!commit())
+            return false;
+
+    if (status == Commited) {
+        if (!QSqlDatabase::database("history").transaction())
+            return false;
+        status = NotCommited;
+    }
+    ++transactionsCounter;
+
+    startAutocommitTimer();
+
+    return true;
+}
+
+bool EDBSqLite::commit()
+{
+    if (status != NotActive) {
+        if (status == Commited || QSqlDatabase::database("history").commit()) {
+            transactionsCounter = 0;
+            lastCommitTime = QDateTime::currentDateTime();
+            status = Commited;
+            stopAutocommitTimer();
+            return true;
+        }
+    }
+    return false;
+}
+
+bool EDBSqLite::rollback()
+{
+    if (status == NotCommited && QSqlDatabase::database("history").rollback()) {
+        transactionsCounter = 0;
+        lastCommitTime = QDateTime::currentDateTime();
+        status = Commited;
+        stopAutocommitTimer();
+        return true;
+    }
+    return false;
+}
+
+void EDBSqLite::startAutocommitTimer()
+{
+    if (!commitTimer) {
+        commitTimer = new QTimer(this);
+        connect(commitTimer, SIGNAL(timeout()), this, SLOT(commit()));
+        commitTimer->setSingleShot(true);
+        commitTimer->setInterval(commitByTimeoutSecs * 1000);
+    }
+    commitTimer->start();
+}
+
+void EDBSqLite::stopAutocommitTimer()
+{
+    if (commitTimer && commitTimer->isActive())
+        commitTimer->stop();
+}
+
+bool EDBSqLite::importExecute()
+{
+    bool res = true;
+    HistoryImport *imp = new HistoryImport(psi());
+    if (imp->isNeeded()) {
+        if (imp->exec() != HistoryImport::ResultNormal) {
+            res = false;
+        }
+    }
+    delete imp;
+    return res;
+}
+
+// ****************** class PreparedQueryes ********************
+
+EDBSqLite::QueryStorage::QueryStorage()
+{
+}
+
+EDBSqLite::QueryStorage::~QueryStorage()
+{
+    foreach (EDBSqLite::PreparedQuery *q, queryList.values()) {
+        if (q)
+            delete q;
+    }
+}
+
+EDBSqLite::PreparedQuery *EDBSqLite::QueryStorage::getPreparedQuery(QueryType type, bool allAccounts, bool allContacts)
+{
+    QueryProperty queryProp(type, allAccounts, allContacts);
+    EDBSqLite::PreparedQuery *q = queryList.value(queryProp, NULL);
+    if (q != NULL)
+        return q;
+
+    q = new EDBSqLite::PreparedQuery(QSqlDatabase::database("history"));
+    q->setForwardOnly(true);
+    q->prepare(getQueryString(type, allAccounts, allContacts));
+    queryList[queryProp] = q;
+    return q;
+}
+
+EDBSqLite::PreparedQuery::PreparedQuery(QSqlDatabase db) : QSqlQuery(db)
+{
+}
+
+QString EDBSqLite::QueryStorage::getQueryString(QueryType type, bool allAccounts, bool allContacts)
+{
+    QString queryStr;
+    switch (type)
+    {
+        case QueryContactsList:
+            queryStr = "SELECT `acc_id`, `jid` FROM `contacts` WHERE `type` = :type";
+            if (!allAccounts)
+                queryStr.append(" AND `acc_id` = :acc_id");
+            queryStr.append(" ORDER BY `jid`;");
+            break;
+        case QueryLatest:
+        case QueryOldest:
+        case QueryDateBackward:
+        case QueryDateForward:
+            queryStr = "SELECT `acc_id`, `events`.`id`, `jid`, `date`, `events`.`type`, `direction`, `subject`, `m_text`, `lang`, `extra_data`"
+                " FROM `events`, `contacts`"
+                " WHERE `contacts`.`id` = `contact_id`";
+            if (!allContacts)
+                queryStr.append(" AND `jid` = :jid");
+            if (!allAccounts)
+                queryStr.append(" AND `acc_id` = :acc_id");
+            if (type == QueryDateBackward)
+                queryStr.append(" AND `date` < :date");
+            else if (type == QueryDateForward)
+                queryStr.append(" AND `date` >= :date");
+            if (type == QueryLatest || type == QueryDateBackward)
+                queryStr.append(" ORDER BY `date` DESC");
+            else
+                queryStr.append(" ORDER BY `date` ASC");
+            queryStr.append(" LIMIT :start, :cnt;");
+            break;
+        case QueryRowCount:
+        case QueryRowCountBefore:
+            queryStr = "SELECT count(*) AS `count`"
+                " FROM `events`, `contacts`"
+                " WHERE `contacts`.`id` = `contact_id`";
+            if (!allContacts)
+                queryStr.append(" AND `jid` = :jid");
+            if (!allAccounts)
+                queryStr.append(" AND `acc_id` = :acc_id");
+            if (type == QueryRowCountBefore)
+                queryStr.append(" AND `date` < :date");
+            queryStr.append(";");
+            break;
+        case QueryJidRowId:
+            queryStr = "SELECT `id` FROM `contacts` WHERE `jid` = :jid AND acc_id = :acc_id;";
+            break;
+        case QueryFindText:
+            queryStr = "SELECT `acc_id`, `events`.`id`, `jid`, `date`, `events`.`type`, `direction`, `subject`, `m_text`, `lang`, `extra_data`"
+                " FROM `events`, `contacts`"
+                " WHERE `contacts`.`id` = `contact_id`";
+            if (!allContacts)
+                queryStr.append(" AND `jid` = :jid");
+            if (!allAccounts)
+                queryStr.append(" AND `acc_id` = :acc_id");
+            queryStr.append(" AND `m_text` IS NOT NULL");
+            queryStr.append(" ORDER BY `date`;");
+            break;
+        case QueryInsertEvent:
+            queryStr = "INSERT INTO `events` ("
+                "`contact_id`, `resource`, `date`, `type`, `direction`, `subject`, `m_text`, `lang`, `extra_data`"
+                ") VALUES ("
+                ":contact_id, :resource, :date, :type, :direction, :subject, :m_text, :lang, :extra_data"
+                ");";
+            break;
+    }
+    return queryStr;
+}
+
+uint qHash(const QueryProperty &struc)
+{
+    uint res = struc.type;
+    res <<= 8;
+    res |=  struc.allAccounts ? 1 : 0;
+    res <<= 8;
+    res |=  struc.allContacts ? 1 : 0;
+    return res;
+}
diff --git a/src/edbsqlite.h b/src/edbsqlite.h
new file mode 100644
index 00000000..1aa8beec
--- /dev/null
+++ b/src/edbsqlite.h
@@ -0,0 +1,165 @@
+/*
+ * edbsqlite.h
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef EDBSQLITE_H
+#define EDBSQLITE_H
+
+#include <QObject>
+#include <QDateTime>
+#include <QTimer>
+#include <QSqlDatabase>
+#include <QSqlQuery>
+#include <QSqlRecord>
+#include <QHash>
+#include <QVariant>
+
+#include "eventdb.h"
+#include "xmpp_jid.h"
+#include "psievent.h"
+#include "edbflatfile.h"
+
+enum QueryType {
+    QueryContactsList,
+    QueryLatest, QueryOldest,
+    QueryDateForward, QueryDateBackward,
+    QueryFindText,
+    QueryRowCount, QueryRowCountBefore,
+    QueryJidRowId,
+    QueryInsertEvent
+};
+
+struct QueryProperty
+{
+    QueryType type;
+    bool      allAccounts;
+    bool      allContacts;
+    QueryProperty(QueryType tp, bool allAcc, bool allCont) {
+        type        = tp;
+        allAccounts = allAcc;
+        allContacts = allCont;
+    }
+    bool operator==(const QueryProperty &other) const {
+        return (type == other.type && allAccounts == other.allAccounts && allContacts == other.allContacts);
+    }
+};
+uint qHash(const QueryProperty &struc);
+
+class EDBSqLite : public EDB
+{
+    Q_OBJECT
+
+    class QueryStorage;
+    class PreparedQuery : private QSqlQuery
+    {
+    public:
+        void bindValue(const QString &placeholder, const QVariant &val) { QSqlQuery::bindValue(placeholder, val); }
+        bool exec() { return QSqlQuery::exec(); }
+        bool first() { return QSqlQuery::first(); }
+        bool next() { return QSqlQuery::next(); }
+        QSqlRecord record() const { return QSqlQuery::record(); }
+        void freeResult() { QSqlQuery::finish(); }
+    private:
+        friend class QueryStorage;
+        PreparedQuery(QSqlDatabase db);
+        ~PreparedQuery() {}
+    };
+    //--------
+    class QueryStorage
+    {
+    public:
+        QueryStorage();
+        ~QueryStorage();
+        PreparedQuery *getPreparedQuery(QueryType type, bool allAccounts, bool allContacts);
+    private:
+        QString getQueryString(QueryType type, bool allAccounts, bool allContacts);
+    private:
+        QHash<QueryProperty, PreparedQuery *> queryList;
+    };
+    //--------
+
+public:
+    enum InsertMode { Normal, Import };
+
+    EDBSqLite(PsiCon *psi);
+    ~EDBSqLite();
+    bool init();
+
+    int features() const;
+    int get(const QString &accId, const XMPP::Jid &jid, const QDateTime date, int direction, int start, int len);
+    int find(const QString &accId, const QString &str, const XMPP::Jid &jid, const QDateTime date, int direction);
+    int append(const QString &accId, const XMPP::Jid &jid, const PsiEvent::Ptr &e, int type);
+    int erase(const QString &accId, const XMPP::Jid &jid);
+    QList<ContactItem> contacts(const QString &accId, int type);
+    quint64 eventsCount(const QString &accId, const XMPP::Jid &jid);
+    QString getStorageParam(const QString &key);
+    void setStorageParam(const QString &key, const QString &val);
+
+    void setInsertingMode(InsertMode mode);
+    void setMirror(EDBFlatFile *mirr);
+    EDBFlatFile *mirror() const;
+
+private:
+    enum { NotActive, NotCommited, Commited };
+    struct item_query_req
+    {
+        QString accId;
+        XMPP::Jid j;
+        int jidType;
+        int type; // 0 = latest, 1 = oldest, 2 = random, 3 = write
+        int start;
+        int len;
+        int dir;
+        int id;
+        QDateTime date;
+        QString findStr;
+        PsiEvent::Ptr event;
+
+        enum Type { Type_get, Type_append, Type_find, Type_erase };
+    };
+    int  status;
+    unsigned int transactionsCounter;
+    QDateTime lastCommitTime;
+    unsigned int maxUncommitedRecs;
+    int maxUncommitedSecs;
+    unsigned int commitByTimeoutSecs;
+    QTimer *commitTimer;
+    EDBFlatFile *mirror_;
+    QList<item_query_req*> rlist;
+    QHash<QString, qint64>jidsCache;
+    QueryStorage queryes;
+
+private:
+    bool appendEvent(const QString &accId, const XMPP::Jid &, const PsiEvent::Ptr &, int);
+    PsiEvent::Ptr getEvent(const QSqlRecord &record);
+    qint64 ensureJidRowId(const QString &accId, const XMPP::Jid &jid, int type);
+    int  rowCount(const QString &accId, const XMPP::Jid &jid, const QDateTime before);
+    bool eraseHistory(const QString &accId, const XMPP::Jid &);
+    bool transaction(bool now);
+    bool rollback();
+    void startAutocommitTimer();
+    void stopAutocommitTimer();
+    bool importExecute();
+
+private slots:
+    void performRequests();
+    bool commit();
+};
+
+#endif // EDBSQLITE_H
diff --git a/src/historyimp.cpp b/src/historyimp.cpp
new file mode 100644
index 00000000..dd81d76e
--- /dev/null
+++ b/src/historyimp.cpp
@@ -0,0 +1,304 @@
+/*
+ * historyimp.cpp
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QDir>
+#include <QTimer>
+#include <QMessageBox>
+#include <QLayout>
+
+#include "historyimp.h"
+#include "edbsqlite.h"
+#include "edbflatfile.h"
+#include "applicationinfo.h"
+#include "psicontactlist.h"
+#include "psiaccount.h"
+#include "psicontact.h"
+
+HistoryImport::HistoryImport(PsiCon *psi) : QObject(),
+    psi_(psi),
+    srcEdb(NULL),
+    dstEdb(NULL),
+    hErase(NULL),
+    hRead(NULL),
+    hWrite(NULL),
+    active(false),
+    result_(ResultNone),
+    recordsCount(0),
+    dlg(NULL)
+{
+}
+
+HistoryImport::~HistoryImport()
+{
+    clear();
+}
+
+bool HistoryImport::isNeeded()
+{
+    bool res = false;
+    EDBSqLite *stor = static_cast<EDBSqLite *>(psi_->edb());
+    if (!stor->getStorageParam("import_start").isEmpty()) {
+        EDB *src = stor->mirror();
+        if (!src)
+            src = new EDBFlatFile(psi_);
+        //if (sou && sou->eventsCount(QString(), XMPP::Jid()) != 0)
+        if (!src->contacts(QString(), EDB::Contact).isEmpty())
+            res = true;
+        else
+            stor->setStorageParam("import_start", QString());
+        if (src != stor->mirror())
+            delete src;
+    }
+    return res;
+}
+
+void HistoryImport::clear()
+{
+    if (dstEdb) {
+        ((EDBSqLite *)dstEdb)->setInsertingMode(EDBSqLite::Normal);
+        ((EDBSqLite *)dstEdb)->setMirror(new EDBFlatFile(psi_));
+    }
+    if (hErase) {
+        delete hErase;
+        hErase = NULL;
+    }
+    if (hRead) {
+        delete hRead;
+        hRead = NULL;
+    }
+    if (srcEdb) {
+        delete srcEdb;
+        srcEdb = NULL;
+    }
+    if (hWrite) {
+        delete hWrite;
+        hWrite = NULL;
+    }
+    if (dlg) {
+        delete dlg;
+        dlg = NULL;
+    }
+}
+
+int HistoryImport::exec()
+{
+    active = true;
+
+    dstEdb = psi_->edb();
+    ((EDBSqLite *)dstEdb)->setMirror(NULL);
+    ((EDBSqLite *)dstEdb)->setInsertingMode(EDBSqLite::Import);
+
+    dstEdb->setStorageParam("import_start", "yes");
+
+    if (!srcEdb)
+        srcEdb = new EDBFlatFile(psi_);
+
+    foreach (const EDB::ContactItem &ci, srcEdb->contacts(QString(), EDB::Contact)) {
+        const XMPP::Jid &jid = ci.jid;
+        QStringList accIds;
+        foreach (PsiAccount *acc, psi_->contactList()->accounts()) {
+            foreach (PsiContact *contact, acc->contactList()) {
+                if (contact->jid() == jid)
+                    accIds.append(acc->id());
+            }
+        }
+        if (accIds.isEmpty()) {
+            PsiAccount *pa = psi_->contactList()->defaultAccount();
+            if (pa)
+                accIds.append(pa->id());
+            else
+                accIds.append(psi_->contactList()->accounts().first()->id());
+        }
+        importList.append(ImportItem(accIds, jid));
+    }
+
+    if (importList.isEmpty())
+        stop(ResultNormal);
+    else
+        showDialog();
+
+    return result_;
+}
+
+void HistoryImport::stop(int reason)
+{
+    stopTime = QDateTime::currentDateTime();
+    result_ = reason;
+    if (reason == ResultNormal) {
+        dstEdb->setStorageParam("import_start", QString());
+        int sec = importDuration();
+        int min = sec / 60;
+        sec = sec % 60;
+        qWarning("%s", QString("Import is finished. Duration is %1 min. %2 sec.").arg(min).arg(sec).toUtf8().constData());
+    }
+    else if (reason == ResultCancel)
+        qWarning("Import canceled");
+    else
+        qWarning("Import error");
+
+    active = false;
+    emit finished(reason);
+}
+
+int HistoryImport::importDuration()
+{
+    return startTime.secsTo(stopTime);
+}
+
+void HistoryImport::readFromFiles()
+{
+    if (!active)
+        return;
+    if (hWrite != NULL) {
+        if (!hWrite->writeSuccess()) {
+            stop(ResultError); // Write error
+            return;
+        }
+    }
+    else if (hErase != NULL && !hErase->writeSuccess()) {
+        stop(ResultError);
+        return;
+    }
+    if (importList.isEmpty()) {
+        stop(ResultNormal);
+        return;
+    }
+    if (hRead == NULL) {
+        hRead = new EDBHandle(srcEdb);
+        connect(hRead, SIGNAL(finished()), this, SLOT(writeToSqlite()));
+    }
+
+    const ImportItem &item = importList.first();
+    int start = item.startNum;
+    if (start == 0)
+        qWarning("%s", QString("Importing %1").arg(JIDUtil::toString(item.jid, true)).toUtf8().constData());
+    --recordsCount;
+    if (dlg && (recordsCount % 100) == 0)
+        progressBar->setValue(progressBar->value() + 1);
+    hRead->get(item.accIds.first(), item.jid, QDateTime(), EDB::Forward, start, 1);
+}
+
+void HistoryImport::writeToSqlite()
+{
+    if (!active)
+        return;
+    const EDBResult r = hRead->result();
+    if (hRead->lastRequestType() != EDBHandle::Read || r.size() > 1) {
+        stop(ResultError);
+        return;
+    }
+    if (r.isEmpty()) {
+        importList.first().accIds.removeFirst();
+        if (importList.first().accIds.isEmpty())
+            importList.removeFirst();
+        QTimer::singleShot(0, this, SLOT(readFromFiles()));
+        return;
+    }
+    if (hWrite == NULL) {
+        hWrite = new EDBHandle(dstEdb);
+        connect(hWrite, SIGNAL(finished()), this, SLOT(readFromFiles()));
+    }
+    EDBItemPtr it = r.first();
+    ImportItem &item = importList.first();
+    hWrite->append(item.accIds.first(), item.jid, it->event(), EDB::Contact);
+    item.startNum += 1;
+}
+
+void HistoryImport::showDialog()
+{
+    dlg = new QDialog();
+    dlg->setModal(true);
+    dlg->setWindowTitle(tr("Psi+ Import history"));
+    QVBoxLayout *mainLayout = new QVBoxLayout(dlg);
+    stackedWidget = new QStackedWidget(dlg);
+
+    QWidget *page1 = new QWidget();
+    QGridLayout *page1Layout = new QGridLayout(page1);
+    QLabel *lbMessage = new QLabel(page1);
+    lbMessage->setWordWrap(true);
+    lbMessage->setText(tr("Found %1 files for import.\nContinue?").arg(importList.size()));
+    page1Layout->addWidget(lbMessage, 0, 0, 1, 1);
+    stackedWidget->addWidget(page1);
+
+    QWidget *page2 = new QWidget();
+    QHBoxLayout *page2Layout = new QHBoxLayout(page2);
+    QGridLayout *page2GridLayout = new QGridLayout();
+    page2GridLayout->addWidget(new QLabel(tr("Status:"), page2), 0, 0, 1, 1);
+    lbStatus = new QLabel(page2);
+    page2GridLayout->addWidget(lbStatus, 0, 1, 1, 1);
+    page2GridLayout->addWidget(new QLabel(tr("Progress:"), page2), 1, 0, 1, 1);
+    progressBar = new QProgressBar(page2);
+    progressBar->setMaximum(1);
+    progressBar->setValue(0);
+    page2GridLayout->addWidget(progressBar, 1, 1, 1, 1);
+    page2Layout->addLayout(page2GridLayout);
+    stackedWidget->addWidget(page2);
+
+    mainLayout->addWidget(stackedWidget);
+    QHBoxLayout *buttonsLayout = new QHBoxLayout();
+    QSpacerItem *buttonsSpacer = new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Minimum);
+    buttonsLayout->addItem(buttonsSpacer);
+    btnOk = new QPushButton(dlg);
+    connect(btnOk, SIGNAL(clicked()), this, SLOT(start()));
+    btnOk->setText(tr("Ok"));
+    buttonsLayout->addWidget(btnOk);
+    QPushButton *btnCancel = new QPushButton(dlg);
+    connect(btnCancel, SIGNAL(clicked()), this, SLOT(cancel()));
+    btnCancel->setText(tr("Exit"));
+    buttonsLayout->addWidget(btnCancel);
+    mainLayout->addLayout(buttonsLayout);
+
+    dlg->adjustSize();
+    dlg->exec();
+}
+
+void HistoryImport::start()
+{
+    qWarning("Import start");
+    startTime = QDateTime::currentDateTime();
+    btnOk->setEnabled(false);
+    stackedWidget->setCurrentIndex(1);
+
+    lbStatus->setText(tr("Counting records"));
+    qApp->processEvents();
+    recordsCount = srcEdb->eventsCount(QString(), XMPP::Jid());
+    int max = recordsCount / 100;
+    if ((recordsCount % 100) != 0)
+        ++max;
+    progressBar->setMaximum(max);
+    progressBar->setValue(0);
+
+    lbStatus->setText(tr("Import"));
+    hErase = new EDBHandle(dstEdb);
+    connect(hErase, SIGNAL(finished()), this, SLOT(readFromFiles()));
+    hErase->erase(QString(), QString());
+    while (active)
+        qApp->processEvents();
+    if (result_ == ResultNormal)
+        dlg->accept();
+    else
+        lbStatus->setText(tr("Error"));
+}
+
+void HistoryImport::cancel()
+{
+    stop();
+    dlg->reject();
+}
diff --git a/src/historyimp.h b/src/historyimp.h
new file mode 100644
index 00000000..fd3c9f4e
--- /dev/null
+++ b/src/historyimp.h
@@ -0,0 +1,91 @@
+/*
+ * historyimp.h
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef HISTORYIMP_H
+#define HISTORYIMP_H
+
+#include <QObject>
+#include <QDialog>
+#include <QLabel>
+#include <QProgressBar>
+#include <QStackedWidget>
+#include <QPushButton>
+
+#include "xmpp/jid/jid.h"
+#include "jidutil.h"
+#include "psicon.h"
+#include "eventdb.h"
+
+struct ImportItem
+{
+    QStringList   accIds;
+    XMPP::Jid     jid;
+    int           startNum;
+    ImportItem(const QStringList &ids, const XMPP::Jid &j) { accIds = ids; jid = j; startNum = 0; }
+};
+
+class HistoryImport : public QObject
+{
+    Q_OBJECT
+
+public:
+    enum {ResultNone, ResultNormal, ResultCancel, ResultError};
+    HistoryImport(PsiCon *psi);
+    ~HistoryImport();
+    bool isNeeded();
+    int exec();
+    int importDuration();
+
+private:
+    PsiCon *psi_;
+    QList<ImportItem> importList;
+    EDB *srcEdb;
+    EDB *dstEdb;
+    EDBHandle *hErase;
+    EDBHandle *hRead;
+    EDBHandle *hWrite;
+    QDateTime startTime;
+    QDateTime stopTime;
+    bool active;
+    int result_;
+    quint64 recordsCount;
+    QDialog *dlg;
+    QLabel *lbStatus;
+    QProgressBar *progressBar;
+    QStackedWidget *stackedWidget;
+    QPushButton *btnOk;
+
+private:
+    void clear();
+    void showDialog();
+
+private slots:
+    void readFromFiles();
+    void writeToSqlite();
+    void start();
+    void stop(int reason = ResultCancel);
+    void cancel();
+
+signals:
+    void finished(int);
+
+};
+
+#endif
diff --git a/src/psicon.cpp b/src/psicon.cpp
index 84a47b5a..07e708ad 100644
--- a/src/psicon.cpp
+++ b/src/psicon.cpp
@@ -62,7 +62,7 @@
 #ifdef HAVE_PGPUTIL
 #include "pgputil.h"
 #endif
-#include "edbflatfile.h"
+#include "edbsqlite.h"
 #include "proxy.h"
 #ifdef PSIMNG
 #include "psimng.h"
@@ -657,7 +657,11 @@ bool PsiCon::init()
 
     checkAccountsEmpty();
 
-    d->edb = new EDBFlatFile(this);
+    // Import for SQLite history
+    EDBSqLite *edb = new EDBSqLite(this);
+    d->edb = edb;
+    if (!edb->init())
+        return false;
 
     if(d->contactList->defaultAccount())
         emit statusMessageChanged(d->contactList->defaultAccount()->status().status());
diff --git a/src/src.pri b/src/src.pri
index 975cb197..e1197acc 100644
--- a/src/src.pri
+++ b/src/src.pri
@@ -161,7 +161,9 @@ HEADERS += \
     $$PWD/translationmanager.h \
     $$PWD/eventdb.h \
     $$PWD/edbflatfile.h \
+    $$PWD/edbsqlite.h \
     $$PWD/historydlg.h \
+    $$PWD/historyimp.h \
     $$PWD/historycontactlistmodel.h \
     $$PWD/tipdlg.h \
     $$PWD/searchdlg.h \
@@ -300,7 +302,9 @@ SOURCES += \
     $$PWD/translationmanager.cpp \
     $$PWD/eventdb.cpp \
     $$PWD/edbflatfile.cpp \
+    $$PWD/edbsqlite.cpp \
     $$PWD/historydlg.cpp \
+    $$PWD/historyimp.cpp \
     $$PWD/historycontactlistmodel.cpp \
     $$PWD/searchdlg.cpp \
     $$PWD/registrationdlg.cpp \
